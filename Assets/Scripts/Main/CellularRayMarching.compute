// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

#define MAX_STEPS 100
#define MAX_DIST 100.0
#define SURF_DIST 0.001

static const float shadowBias = SURF_DIST * 10;

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
Texture2D<float4> Source;
RWTexture2D<float4> Destination;

float4x4 _CameraToWorld;
float4x4 _CameraInverseProjection;

float3 _Light;
bool positionLight;

struct Ray {
    float3 origin;
    float3 direction;
};

struct Cell {
    float3 pos;
    float3 size;
    float3 color;
};

StructuredBuffer<Cell>  cells;
int                     numCells;

RWTexture3D <float4>    automatum;
int                     width;
int                     height;
int                     depth;

Ray CreateRay(float3 origin, float3 direction) {
    Ray ray;
    ray.origin = origin;
    ray.direction = direction;
    return ray;
}

Ray CreateCameraRay(float2 uv) {
    float3 origin = mul(_CameraToWorld, float4(0, 0, 0, 1)).xyz;
    float3 direction = mul(_CameraInverseProjection, float4(uv, 0, 1)).xyz;
    direction = mul(_CameraToWorld, float4(direction, 0)).xyz;
    direction = normalize(direction);
    return CreateRay(origin, direction);
}

// polynomial smooth min (k = 0.1);
// from https://www.iquilezles.org/www/articles/smin/smin.htm
float4 Blend(float a, float b, float3 colA, float3 colB, float k)
{
    float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);
    float blendDst = lerp(b, a, h) - k * h * (1.0 - h);
    float3 blendCol = lerp(colB, colA, h);
    return float4(blendCol, blendDst);
}

float DistanceExampleSphere(float3 p) {
    float4 s = float4(2, 2, 0, 2);

    float sphereDist = length(p - s.xyz) - s.w;

    return sphereDist;
}

//Cell = Box
float DistanceCell(float3 eye, float3 centre, float3 size) {
    //float3 o = abs(eye - centre) - size;
   // float ud = length(max(o, 0));
   // float n = max(max(min(o.x, 0), min(o.y, 0)), min(o.z, 0));
    
   // return ud + n;
    return length(eye - centre) - size;
}


float4 Combine(float dstA, float dstB, float3 colorA, float3 colorB, float blendStrength) {

    float4 blend = Blend(dstA, dstB, colorA, colorB, blendStrength);
    float dst = blend.w;
    float3 color = blend.xyz;
   
    return float4(color, dst);
}

float4 RayMarching(float3 p) {

    float3 color = 1;
    float dist = MAX_DIST;

    //iterate over all cells and calc color as well as distance for each point p
    /*for (int i = 0; i < numCells; i++) {
        Cell cell = cells[i];
       
        float localD = DistanceCell(p, cell.pos,cell.size);
        float3 localColor = cell.color;

        float4 globalCombined = Combine(dist , localD, color, localColor, 0.9);
        
        color = globalCombined.xyz;
        dist  = globalCombined.w;
     
    }*/


    for (int w = 0; w < width; w++) {
        for (int d = 0; d < depth; d++) {
            for (int h = 0; h < height; h++) {
                    float localD =  DistanceCell(p, float3(w, h, d), float3(0.5, 0.5, 0.5));
                    float3 localColor = automatum[float3(w, h, d)].xyz;
              
                    float4 globalCombined = Combine(dist, localD, color, localColor, 0.9);

                    color = globalCombined.xyz;
                    dist = globalCombined.w;            
            }
        }
    }

    return float4(color, dist);
}


float3 GetNormal(float3 p) {
    float x = RayMarching(float3(p.x + SURF_DIST, p.y, p.z)).w - RayMarching(float3(p.x - SURF_DIST, p.y, p.z)).w;
    float y = RayMarching(float3(p.x, p.y + SURF_DIST, p.z)).w - RayMarching(float3(p.x, p.y - SURF_DIST, p.z)).w;
    float z = RayMarching(float3(p.x, p.y, p.z + SURF_DIST)).w - RayMarching(float3(p.x, p.y, p.z - SURF_DIST)).w;
    return normalize(float3(x, y, z));
}

float CalculateShadow(Ray ray, float dstToShadePoint) {
    float rayDst = 0;
    int marchSteps = 0;
    float shadowIntensity = .2;
    float brightness = 1;

    while (rayDst < dstToShadePoint) {
        marchSteps++;
        float dst = RayMarching(ray.origin).w;

        if (dst <= SURF_DIST) {
            return shadowIntensity;
        }

        brightness = min(brightness, dst * 200);

        ray.origin += ray.direction * dst;
        rayDst += dst;
    }
    return shadowIntensity + (1 - shadowIntensity) * brightness;
}

[numthreads(8, 8, 1)]
void CSMain(uint3 id : SV_DispatchThreadID)
{
    uint width, height;
    Destination.GetDimensions(width, height);

    Destination[id.xy] = Source[id.xy];

    float2 uv = id.xy / float2(width, height) * 2 - 1;
    float rayDst = 0;

    Ray ray = CreateCameraRay(uv);
    int marchSteps = 0;

    while (rayDst < MAX_DIST) {
        marchSteps++;
        float4 sceneInfo = RayMarching(ray.origin);
        float dst = sceneInfo.w;

        if (dst <= SURF_DIST) {
            float3 pointOnSurface = ray.origin + ray.direction * dst;
            float3 normal = GetNormal(pointOnSurface - ray.direction * SURF_DIST);
            float3 lightDir = (positionLight) ? normalize(_Light - ray.origin) : -_Light;
            float lighting = saturate(saturate(dot(normal, lightDir)));
            float3 color = sceneInfo.xyz;

            // Shadow
            float3 offsetPos = pointOnSurface + normal * shadowBias;
            float3 dirToLight = (positionLight) ? normalize(_Light - offsetPos) : -_Light;

            ray.origin = offsetPos;
            ray.direction = dirToLight;

            float dstToLight = (positionLight) ? distance(offsetPos, _Light) : MAX_DIST;
            float shadow = CalculateShadow(ray, dstToLight);

            Destination[id.xy] = float4(color * lighting * shadow, 1);

            break;
        }

        ray.origin += ray.direction * dst;
        rayDst += dst;
    }
}
