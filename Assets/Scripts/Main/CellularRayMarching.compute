// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

#define MAX_STEPS 200
#define MAX_DIST 100.0
#define SURF_DIST 0.001

static const float shadowBias = SURF_DIST * 10;

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
Texture2D<float4> Source;
RWTexture2D<float4> Destination;



float4x4 _CameraToWorld;
float4x4 _CameraInverseProjection;

float3 _Light;
bool positionLight;

struct Ray {
    float3 origin;
    float3 direction;
};

struct Cell {
    float3 pos;
    float3 size;
    float3 color;
};

StructuredBuffer<Cell> cells;
int                     numCells;

Ray CreateRay(float3 origin, float3 direction) {
    Ray ray;
    ray.origin = origin;
    ray.direction = direction;
    return ray;
}

Ray CreateCameraRay(float2 uv) {
    float3 origin = mul(_CameraToWorld, float4(0, 0, 0, 1)).xyz;
    float3 direction = mul(_CameraInverseProjection, float4(uv, 0, 1)).xyz;
    direction = mul(_CameraToWorld, float4(direction, 0)).xyz;
    direction = normalize(direction);
    return CreateRay(origin, direction);
}

// polynomial smooth min (k = 0.1);
// from https://www.iquilezles.org/www/articles/smin/smin.htm
float4 Blend(float a, float b, float3 colA, float3 colB, float k)
{
    float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);
    float blendDst = lerp(b, a, h) - k * h * (1.0 - h);
    float3 blendCol = lerp(colB, colA, h);
    return float4(blendCol, blendDst);
}


// polynomial smooth min (k = 0.1);
// from https://www.iquilezles.org/www/articles/smin/smin.htm
float  BlendDst(float a, float b, float k)
{
    float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);
    float blendDst = lerp(b, a, h) - k * h * (1.0 - h);
    return blendDst;
}

float DistanceSphere(float3 p) {
    float4 s = float4(2, 2, 0, 2);

    float sphereDist = length(p - s.xyz) - s.w;

    return sphereDist;
}

float DistanceCell(float3 eye, float3 centre, float3 size) {
    float3 o = abs(eye - centre) - size;
    float ud = length(max(o, 0));
    float n = max(max(min(o.x, 0), min(o.y, 0)), min(o.z, 0));
    return ud + n;
}





float4 Combine(float dstA, float dstB, float3 colourA, float3 colourB, int operation, float blendStrength) {
    float dst = dstA;
    float3 colour = colourA;


    if (operation == 0) {
        if (dstB < dstA) {
            dst = dstB;
            colour = colourB;
        }
    }
    // Blend
    else if (operation == 1) {
        float4 blend = Blend(dstA, dstB, colourA, colourB, blendStrength);
        dst = blend.w;
        colour = blend.xyz;
    }
    // Cut
    else if (operation == 2) {
        // max(a,-b)
        if (-dstB > dst) {
            dst = -dstB;
            colour = colourB;
        }
    }
    // Mask
    else if (operation == 3) {
        // max(a,b)
        if (dstB > dst) {
            dst = dstB;
            colour = colourB;
        }
    }

    return float4(colour, dst);
}

float4 RayMarching(float3 p) {

    float3 color = 1;
    float dist = MAX_DIST;

    for (int i = 0; i < numCells; i++) {
        Cell cell = cells[i];

       
        float localD = DistanceCell(p, cell.pos,cell.size);
        float3 localColor = cell.color;

        float4 globalCombined = Combine(dist , localD, color, localColor, 1, 0.9);
        color = globalCombined.xyz;
        dist = globalCombined.w;
        
   
    }
    

    return float4(color, dist);
}


float3 GetNormal(float3 p) {
    float x = RayMarching(float3(p.x + SURF_DIST, p.y, p.z)).w - RayMarching(float3(p.x - SURF_DIST, p.y, p.z)).w;
    float y = RayMarching(float3(p.x, p.y + SURF_DIST, p.z)).w - RayMarching(float3(p.x, p.y - SURF_DIST, p.z)).w;
    float z = RayMarching(float3(p.x, p.y, p.z + SURF_DIST)).w - RayMarching(float3(p.x, p.y, p.z - SURF_DIST)).w;
    return normalize(float3(x, y, z));
}

float CalculateShadow(Ray ray, float dstToShadePoint) {
    float rayDst = 0;
    int marchSteps = 0;
    float shadowIntensity = .2;
    float brightness = 1;

    while (rayDst < dstToShadePoint) {
        marchSteps++;
        float dst = RayMarching(ray.origin).w;

        if (dst <= SURF_DIST) {
            return shadowIntensity;
        }

        brightness = min(brightness, dst * 200);

        ray.origin += ray.direction * dst;
        rayDst += dst;
    }
    return shadowIntensity + (1 - shadowIntensity) * brightness;
}
[numthreads(8, 8, 1)]
void CSMain(uint3 id : SV_DispatchThreadID)
{
    uint width, height;
    Destination.GetDimensions(width, height);

    Destination[id.xy] = Source[id.xy];

    float2 uv = id.xy / float2(width, height) * 2 - 1;
    float rayDst = 0;

    Ray ray = CreateCameraRay(uv);
    int marchSteps = 0;

    while (rayDst < MAX_DIST) {
        marchSteps++;
        float4 sceneInfo = RayMarching(ray.origin);
        float dst = sceneInfo.w;

        if (dst <= SURF_DIST) {
            float3 pointOnSurface = ray.origin + ray.direction * dst;
            float3 normal = GetNormal(pointOnSurface - ray.direction * SURF_DIST);
            float3 lightDir = (positionLight) ? normalize(_Light - ray.origin) : -_Light;
            float lighting = saturate(saturate(dot(normal, lightDir)));
            float3 col = sceneInfo.xyz;

            // Shadow
            float3 offsetPos = pointOnSurface + normal * shadowBias;
            float3 dirToLight = (positionLight) ? normalize(_Light - offsetPos) : -_Light;

            ray.origin = offsetPos;
            ray.direction = dirToLight;

            float dstToLight = (positionLight) ? distance(offsetPos, _Light) : MAX_DIST;
            float shadow = CalculateShadow(ray, dstToLight);

            Destination[id.xy] = float4(col * lighting * shadow, 1);

            break;
        }

        ray.origin += ray.direction * dst;
        rayDst += dst;
    }
}
