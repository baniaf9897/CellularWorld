// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

#define MAX_STEPS 200
#define MAX_DIST 100.0
#define SURF_DIST 0.001

static const float shadowBias = SURF_DIST * 10;

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
Texture2D<float4> Source;
RWTexture2D<float4> Destination;


float4x4 _CameraToWorld;
float4x4 _CameraInverseProjection;

float3 _Light;
bool positionLight;

struct Ray {
    float3 origin;
    float3 direction;
};

Ray CreateRay(float3 origin, float3 direction) {
    Ray ray;
    ray.origin = origin;
    ray.direction = direction;
    return ray;
}

Ray CreateCameraRay(float2 uv) {
    float3 origin = mul(_CameraToWorld, float4(0, 0, 0, 1)).xyz;
    float3 direction = mul(_CameraInverseProjection, float4(uv, 0, 1)).xyz;
    direction = mul(_CameraToWorld, float4(direction, 0)).xyz;
    direction = normalize(direction);
    return CreateRay(origin, direction);
}

// polynomial smooth min (k = 0.1);
// from https://www.iquilezles.org/www/articles/smin/smin.htm
float4 Blend(float a, float b, float3 colA, float3 colB, float k)
{
    float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);
    float blendDst = lerp(b, a, h) - k * h * (1.0 - h);
    float3 blendCol = lerp(colB, colA, h);
    return float4(blendCol, blendDst);
}


// polynomial smooth min (k = 0.1);
// from https://www.iquilezles.org/www/articles/smin/smin.htm
float  BlendDst(float a, float b, float k)
{
    float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);
    float blendDst = lerp(b, a, h) - k * h * (1.0 - h);
    return blendDst;
}

float DistanceSphere(float3 p) {
    float4 s = float4(0, 1, 6, 1);

    float sphereDist = length(p - s.xyz) - s.w;
    float planeDist = p.y;

    return min(sphereDist, planeDist);
}

float DistanceCell(float3 eye, float3 centre, float3 size) {
    float3 o = abs(eye - centre) - size;
    float ud = length(max(o, 0));
    float n = max(max(min(o.x, 0), min(o.y, 0)), min(o.z, 0));
    return ud + n;
}


float GetDistance(float3 p) {
    //iterate over all available cells....
    //use min or some interpolation to union these cells into one shape


    return min(DistanceCell(p,float3(0.2,0.2,0.2),float3(2.0,2.0,1.0)), DistanceCell(p, float3(4.5, 0.2, 0.2), float3(2.0, 2.0, 1.0)));
}



float3 GetNormal(float3 p) {
    float d = GetDistance(p);
    float2 e = float2(.01, 0);

    float3 n = d - float3(
        GetDistance(p - e.xyy),
        GetDistance(p - e.yxy),
        GetDistance(p - e.yyx));

    return normalize(n);
}

float CalculateShadow(Ray ray, float dstToShadePoint) {
    float rayDst = 0;
    int marchSteps = 0;
    float shadowIntensity = .2;
    float brightness = 1;

    while (rayDst < dstToShadePoint) {
        marchSteps++;
        float dst = GetDistance(ray.origin);

        if (dst <= SURF_DIST) {
            return shadowIntensity;
        }

        brightness = min(brightness, dst * 200);

        ray.origin += ray.direction * dst;
        rayDst += dst;
    }
    return shadowIntensity + (1 - shadowIntensity) * brightness;
}


float4 RayMarching(float3 p) {
 
    float3 color = 1;
    float d = MAX_DIST;

    d = GetDistance(p);

    return float4(color, d);
}
[numthreads(8,8,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    uint width, height;
    Destination.GetDimensions(width, height);

    Destination[id.xy] = Source[id.xy];

    float2 uv = id.xy / float2(width, height) * 2 - 1;
    float rayDst = 0;

    Ray ray = CreateCameraRay(uv);
    int marchSteps = 0;

    while (rayDst < MAX_DIST) {
        marchSteps++;
        float4 sceneInfo = RayMarching(ray.origin);
        float dst = sceneInfo.w;

        if (dst <= SURF_DIST) {
            float3 pointOnSurface = ray.origin + ray.direction * dst;
            float3 normal = GetNormal(pointOnSurface - ray.direction * SURF_DIST);
            float3 lightDir = (positionLight) ? normalize(_Light - ray.origin) : -_Light;
            float lighting = saturate(saturate(dot(normal, lightDir)));
            float3 col = sceneInfo.xyz;

            // Shadow
            float3 offsetPos = pointOnSurface + normal * shadowBias;
            float3 dirToLight = (positionLight) ? normalize(_Light - offsetPos) : -_Light;

            ray.origin = offsetPos;
            ray.direction = dirToLight;

            float dstToLight = (positionLight) ? distance(offsetPos, _Light) : MAX_DIST;
            float shadow = CalculateShadow(ray, dstToLight);

            Destination[id.xy] = float4(col * lighting * shadow, 1);

            break;
        }

        ray.origin += ray.direction * dst;
        rayDst += dst;
    }
 }
